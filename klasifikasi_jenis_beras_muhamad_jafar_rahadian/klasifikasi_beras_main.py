# -*- coding: utf-8 -*-
"""klasifikasi_beras_main.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bLJT9hX2w0gvX2MYysjsexTLhY8AtUEO

# Proyek Klasifikasi Gambar: [Klasifikasi Jenis Beras]
- **Nama:** [Muhamad Jafar Rahadian]
- **Email:** [muhammadjafar954@gmail.com]
- **ID Dicoding:** [jafarrahadian]
- **Sumber Dataset:**[https://www.kaggle.com/datasets/muratkokludataset/rice-image-dataset]

Koklu, M., Cinar, I., & Taspinar, Y. S. (2021). Classification of rice varieties with deep learning methods. Computers and Electronics in Agriculture, 187, 106285. https://doi.org/10.1016/j.compag.2021.106285

### 1. Import Semua Packages/Library yang Digunakan
"""

import matplotlib.image as mpimg
import matplotlib.pyplot as plt
import numpy as np
import os
import pandas as pd
import seaborn as sns
import pathlib
import PIL
import seaborn as sns
import tensorflow as tf
import zipfile

from tensorflow import keras

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder

print(tf.__version__)

"""### 2. Data Preparation

Menyiapkan data

**Dataset di Upload secara manual karena saya menggunakan docker sebagai runtime, dataset dapat di akses melalui : https://drive.google.com/file/d/1x-OBlXgbP0XOuYqyCKwm8lk2uUM_4ggv/view?usp=sharing**
"""

#import file dan ekstrak dataset
zip_file_path = "/content/dataset_beras.zip"

with zipfile.ZipFile(zip_file_path, 'r') as zip_ref:
    zip_ref.extractall("/content/")

#isi direktori dataset
base_dir = '/content/dataset_beras'
!ls {base_dir}

"""Loading Data"""

#melihat banyaknya data
arborio_dir = pathlib.Path(base_dir + '/Arborio')
basmati_dir = pathlib.Path(base_dir + '/Basmati')
ipsala_dir = pathlib.Path(base_dir + '/Ipsala')
jasmine_dir = pathlib.Path(base_dir + '/Jasmine')
karacadag_dir = pathlib.Path(base_dir + '/Karacadag')

print("Jumlah Gambar Beras pada Dataset :")
print("Arborio: ", len(list(arborio_dir.glob('*'))))
print("Basmati: ", len(list(basmati_dir.glob('*'))))
print("Ipsala: ", len(list(ipsala_dir.glob('*'))))
print("Jasmine: ", len(list(jasmine_dir.glob('*'))))
print("Karacadag: ", len(list(karacadag_dir.glob('*'))))

# Visualisasi beberapa gambar dari setiap kelas
num_images_to_display = 4  # Jumlah gambar yang ingin ditampilkan per kelas

classes = ['Arborio', 'Basmati', 'Ipsala', 'Jasmine', 'Karacadag']

plt.figure(figsize=(15, 10))

for i, class_name in enumerate(classes):
    class_dir = pathlib.Path(base_dir + '/' + class_name)
    images = list(class_dir.glob('*'))

    for j in range(num_images_to_display):
        if j < len(images):
          img_path = str(images[j])
          img = mpimg.imread(img_path)
          plt.subplot(len(classes), num_images_to_display, i * num_images_to_display + j + 1)
          plt.imshow(img)
          plt.title(class_name)
          plt.axis('off')
        else:
          # Jika tidak ada cukup gambar, buat subplot kosong
          plt.subplot(len(classes), num_images_to_display, i * num_images_to_display + j + 1)
          plt.axis('off')

plt.tight_layout()
plt.show()

"""### 3. Data Preprocessing

**80% Data Train & 20% Data test**
"""

images = []
labels = []

for class_name in classes:
    class_dir = pathlib.Path(base_dir + '/' + class_name)
    for image_path in class_dir.glob('*'):
        images.append(str(image_path))
        labels.append(class_name)

df = pd.DataFrame({'image': images, 'label': labels})
X_train, X_test, y_train, y_test = train_test_split(df['image'], df['label'], test_size=0.2, random_state=42)

df_train = pd.DataFrame({'image': X_train, 'label': y_train})

df_test = pd.DataFrame({'image': X_test, 'label': y_test})

encoder = LabelEncoder()
y_train = encoder.fit_transform(y_train)
y_test = encoder.transform(y_test)

"""### 4. Augmentasi Data"""

image_size = (150, 150)
batch_size = 32

datagen = tf.keras.preprocessing.image.ImageDataGenerator(
    rescale=1./255,
    rotation_range=20,
    width_shift_range=0.2,
    height_shift_range=0.2,
    zoom_range=0.2,
    shear_range=0.2,
    horizontal_flip=True,
    fill_mode='nearest'
)
testing_generator = datagen.flow_from_dataframe(
    df_test,
    x_col='image',
    y_col='label',
    target_size= image_size,
    batch_size= batch_size,
    class_mode='categorical',
    shuffle=False
)
training_generator = datagen.flow_from_dataframe(
    df_train,
    x_col='image',
    y_col='label',
    target_size= image_size,
    batch_size= batch_size,
    class_mode='categorical',
    shuffle=True
)

"""### 5. Pembentukkan Model"""

model = tf.keras.models.Sequential([
    tf.keras.layers.Conv2D(32, (3,3), activation='relu', input_shape=(150, 150, 3)),
    tf.keras.layers.MaxPooling2D(2, 2),
    tf.keras.layers.Conv2D(64, (3,3), activation='relu'),
    tf.keras.layers.MaxPooling2D(2,2),
    tf.keras.layers.Flatten(),
    tf.keras.layers.Dense(128, activation='relu'),
    tf.keras.layers.Dropout(0.2),
    tf.keras.layers.Dense(5, activation='softmax')
    ])

model.compile(loss = 'categorical_crossentropy',
              optimizer=tf.optimizers.Adam(),
              metrics=['accuracy'])
model.summary()

#layer yabg digunakan
for i, layer in enumerate(model.layers):
    print(i, layer.name)

class myCallback(tf.keras.callbacks.Callback):
  def on_epoch_end(self, epoch, logs={}):
    if(logs.get('accuracy')>0.96):
      print("\nAkurasi telah mencapai >96%!")
      self.model.stop_training = True

callbacks = myCallback()

history = model.fit(
    training_generator,
    epochs=16,
    validation_data=testing_generator,
    verbose=1,
    callbacks=[callbacks]
)

"""### 6. Evaluasi dan Visualisasi Model



"""

def plot_accuracy(history):
  plt.plot(history.history['accuracy'], label='training accuracy')
  plt.plot(history.history['val_accuracy'], label='validation accuracy')
  plt.title('Model Accuracy')
  plt.ylabel('Accuracy')
  plt.xlabel('Epoch')
  plt.legend(loc='best')
  plt.show()

def plot_loss(history):
  plt.plot(history.history['loss'], label="training loss")
  plt.plot(history.history['val_loss'], label='validation loss')
  plt.title('Model loss')
  plt.ylabel('Loss')
  plt.xlabel('Epoch')
  plt.legend(loc='best')
  plt.show()

plot_accuracy(history)
plot_loss(history)

loss, valid_accuracy = model.evaluate(testing_generator)
print(f"Accuracy model CNN: {valid_accuracy * 100:.2f}%")

"""### 7. Konversi Model

"""

# Save the model as a .h5 file
model.save('beras_model.h5')

# Convert and save the model to TensorFlow Lite format
converter = tf.lite.TFLiteConverter.from_keras_model(model)
tflite_model = converter.convert()

with open('beras_model.tflite', 'wb') as f:
  f.write(tflite_model)

# Save class labels to a text file for TensorFlow Lite
# Define the actual class labels
class_labels = ['Arborio', 'Basmati', 'Ipsala', 'Jasmine', 'Karacadag']

with open('labels.txt', 'w') as f:
  for label in class_labels:  # Iterate over the class labels
      f.write(label + '\n')

# Convert and save the model to TensorFlow.js format
import tensorflowjs as tfjs

tfjs.converters.save_keras_model(model, 'beras_model_tfjs')

# Save the model as a .pb file (SavedModel format)
model.export('beras_model_pb')

"""### 8. Inference (Opsional)"""

from tensorflow.keras.preprocessing.image import load_img, img_to_array
# Load the TFLite model
interpreter = tf.lite.Interpreter(model_path="beras_model.tflite")
interpreter.allocate_tensors()

# Get input and output details
input_details = interpreter.get_input_details()
output_details = interpreter.get_output_details()

# Define the image path for inference
image_path = '/content/dataset_beras/Karacadag/Karacadag (10).jpg'

# Preprocess the image
img = load_img(image_path, target_size=(150, 150))
x = img_to_array(img)
x = np.expand_dims(x, axis=0)
x = x / 255.0

# Set the input tensor
interpreter.set_tensor(input_details[0]['index'], x)

# Run inference
interpreter.invoke()

# Get the output tensor
output_data = interpreter.get_tensor(output_details[0]['index'])

# Get the predicted class
predicted_class = np.argmax(output_data)

# Define class labels
class_labels = ['Arborio', 'Basmati', 'Ipsala', 'Jasmine', 'Karacadag']

# Print the prediction
print(f"Predicted class: {class_labels[predicted_class]}")

# Display the image
plt.imshow(img)
plt.title(f"Prediction: {class_labels[predicted_class]}")
plt.axis('off')
plt.show()

!pip freeze > requirements.txt